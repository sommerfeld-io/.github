= ADR: Update repositores from `.github` repo vs. Reuseable Workflow in every repo
Sebastian Sommerfeld <sebastian@sommerfeld.io>

This Architecture Decision Record is a direct consequence of the issue link:https://github.com/sommerfeld-io/.github/issues/3[Refactor central management of  linter rulesets (the resprctive files like `.yamllint.yml` - #3].

[cols="1,1,1",options="header"]
|===
|Proposed on |Accepted on |Declined on
|2023-07-16  |2023-07-16  |-
|===

== Context
I aimed to create a centralized approach for managing common files, such as linter rulesets, across all repositories. To achieve this, I implemented a matrix workflow in the link:https://github.com/sommerfeld-io/.github/[.github] repository. This workflow utilized the link:https://cli.github.com/[GitHub CLI] to iterate through each repository and created a  matrix-element for each repository. Each matrix-element should update files for a single repository by cloning the repository, copying files into its filesystem and pushing the changes to the remote repository.

The proboem is, that the `GITHUB_TOKEN` used in the workflow only grants permissions for the repository where the workflow was hosted. Writing to other repositories resulted in the error message `Error: Pushing to https://github.com/sommerfeld-io/infrastructure-config - remote: Permission to sommerfeld-io/infrastructure-config.git denied to github-actions[bot]`. Consequently, I was unable to write files to other repositories.

.Click to show workflow code that was causing the issues
[%collapsible]
====
[source,yml]
----
include::ROOT:example$adr-2023-07-16-global-update-workflows-vs-reusable-workflows/housekeeping-linter-rules.yml[]
----
====

=== Solution #1
One option involved generating a personal access token (PAT) with the necessary permissions to access and write files in the target repositories. By using this PAT in the workflow, I could overcome the restrictions of the `GITHUB_TOKEN` and successfully write files to the desired repositories.

NOTE: Replace me with some thought about the following questions: Why do we think about this in the first place? What was the trigger? Why is this worth an ADR? WHy is this not just a smaller / local descision for a single repo? Why should this affect all repositories / future considerations?

=== Solution #2
Another solution to address the limitation is to have each repository maintain its own housekeeping workflow responsible for updating linter rules. This workflow can make use of reusable workflows available in the .github repository to avoid duplication and manage the workflow logic in a central location.

With this approach, the workflow logic remains the same. It involves cloning the source repository (containing the linter rules) and the target repository (hosting the workflow), copying the necessary files, and pushing the changes upstream. The advantage is that the GITHUB_TOKEN privileges are sufficient since each workflow only writes to its own repository.

By implementing this solution, repositories can autonomously manage their linter rules without relying on a central workflow, ensuring more granular control and reducing dependencies on external permissions.

== Decision
Solution 1 was not chosen due to the desire to avoid managing additional secrets beyond what is necessary.

Since each repository already has housekeeping workflows utilizing Reusable Workflows, Solution 2 is the way to go.

This approach ensures that changes are only written to a repository by human developers or workflows originating from the same repository. This aligns with established workflow patterns, such as auto-generating documentation, where workflows in each repository write to their own repository as well, maintaining consistency and maintaining secure control over changes.

== Consequences
It is necessary to manually ensure that the housekeeping workflow is present in each repository. While central workflows can still be utilized, their functionality is limited to reading information from other repositories or all repositories collectively. These central workflows do not write any files to repositories other than their own. Writing operations should be handled independently by each repository, ensuring that repositories maintain control over their own files and reducing potential conflicts or unintended modifications.